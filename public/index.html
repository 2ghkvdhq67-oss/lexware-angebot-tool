'use strict';

/**
 * Maiershirts — Lexware/Lexoffice Angebots-Tool (Render.com)
 * KOMPLETT server.js — wie vorher, keine Funktionen entfernt, nur ergänzt:
 * ✅ Lexware API Originalantwort IMMER im Response-Feld `technical`
 * ✅ Automatisch unitPrice setzen (Fix für 406: "The unit price must not be null.")
 * ✅ Template-Download /templates/lexware_template.xlsx (Alias, Dateiname egal)
 * ✅ Passwortschutz (TOOL_PASSWORD im Body ODER Basic Auth APP_USER/APP_PASS)
 * ✅ Rate-Limit handling (TokenBucket 2 req/s + Retry bei 429)
 * ✅ Idempotency gegen 3× Erstellung (Doppelklick/Retry)
 *
 * Endpoints:
 *  GET  /api/ping
 *  GET  /api/articles
 *  POST /api/test-excel
 *  POST /api/create-offer
 *  GET  /api/download-pdf?id=...
 *
 * Excel Sheets:
 *  Angebot / Kunde / Positionen
 */

require('dotenv').config();

const path = require('path');
const fs = require('fs');
const crypto = require('crypto');

const express = require('express');
const axios = require('axios');
const XLSX = require('xlsx');

const app = express();
app.use(express.json({ limit: '25mb' }));

// ------------------------------------------------------------
// ENV
// ------------------------------------------------------------
const API_KEY = process.env.LEXOFFICE_API_KEY || process.env.LEXWARE_API_KEY || '';
const API_BASE_URL = (process.env.LEXOFFICE_API_BASE_URL || process.env.LEXWARE_API_BASE_URL || 'https://api.lexware.io')
  .replace(/\/+$/, '');

const TOOL_PASSWORD = process.env.TOOL_PASSWORD || '';
const APP_USER = process.env.APP_USER || '';
const APP_PASS = process.env.APP_PASS || '';

const ALLOW_PRICE_OVERRIDE_DEFAULT =
  (process.env.ALLOW_PRICE_OVERRIDE_DEFAULT || process.env.ALLOW_PRICE_OVERRIDE || 'false').toLowerCase() === 'true';

const FINALIZE_DEFAULT = (process.env.FINALIZE_DEFAULT || 'true').toLowerCase() === 'true';

// optional extra buffer interval (in ms) zusätzlich zum TokenBucket
const MIN_INTERVAL_MS = Number(process.env.LEXWARE_MIN_INTERVAL_MS || '0');

// ------------------------------------------------------------
// Static: public + templates
// ------------------------------------------------------------
app.use(express.static(path.join(__dirname, 'public')));
app.use('/templates', express.static(path.join(__dirname, 'templates')));

// Root (gegen "Cannot GET /")
app.get('/', (req, res) => res.sendFile(path.join(__dirname, 'public', 'index.html')));

// Template Alias: /templates/lexware_template.xlsx
// => liefert *irgendeine* passende .xlsx aus templates/ (bevorzugt Lexware_Template.xlsx)
app.get('/templates/lexware_template.xlsx', (req, res) => {
  const templatesDir = path.join(__dirname, 'templates');
  const preferred = [
    'Lexware_Template.xlsx',
    'lexware_template.xlsx',
    'lexware_template.XLSX',
    'Lexware_Template.XLSX',
  ].map(n => path.join(templatesDir, n));

  let filePath = preferred.find(p => fs.existsSync(p));

  if (!filePath) {
    try {
      const candidates = fs.existsSync(templatesDir)
        ? fs.readdirSync(templatesDir).filter(f => f.toLowerCase().endsWith('.xlsx'))
        : [];
      if (candidates.length) filePath = path.join(templatesDir, candidates[0]);
    } catch { /* ignore */ }
  }

  if (!filePath || !fs.existsSync(filePath)) {
    return res.status(404).send('Template-Datei nicht gefunden. Lege eine .xlsx in /templates ab.');
  }
  res.sendFile(filePath);
});

// ------------------------------------------------------------
// Helpers: technical payload (bombensicher)
// ------------------------------------------------------------
function safeJson(v) {
  try {
    if (v === undefined) return null;
    return JSON.parse(JSON.stringify(v));
  } catch {
    try { return String(v); } catch { return null; }
  }
}

function extractMeta(raw) {
  const r = raw || {};
  return {
    timestamp: r.timestamp || null,
    status: r.status || null,
    error: r.error || null,
    message: r.message || null,
    path: r.path || null,
    traceId: r.traceId || null,
    requestId: r.requestId || null,
    details: Array.isArray(r.details) ? r.details : null,
  };
}

function buildTechnical({ httpStatus, raw, err }) {
  const rawSafe = safeJson(raw);
  return {
    httpStatus: httpStatus ?? null,
    raw: rawSafe,
    meta: extractMeta(rawSafe),
    errorMessage: err?.message || null,
  };
}

function ok(res, payload) {
  return res.json({ ok: true, ...payload });
}

function fail(res, payload) {
  // immer technical garantieren, wenn möglich
  if (!payload.technical && (payload.httpStatus || payload.raw || payload.err)) {
    payload.technical = buildTechnical({ httpStatus: payload.httpStatus, raw: payload.raw, err: payload.err });
    delete payload.httpStatus;
    delete payload.raw;
    delete payload.err;
  }
  return res.json({ ok: false, ...payload });
}

// ------------------------------------------------------------
// Auth: Basic Auth optional ODER TOOL_PASSWORD im Body
// ------------------------------------------------------------
function parseBasicAuth(header) {
  if (!header || !header.startsWith('Basic ')) return null;
  const b64 = header.slice(6);
  try {
    const decoded = Buffer.from(b64, 'base64').toString('utf8');
    const idx = decoded.indexOf(':');
    if (idx < 0) return null;
    return { user: decoded.slice(0, idx), pass: decoded.slice(idx + 1) };
  } catch {
    return null;
  }
}

function basicAuthMiddleware(req, res, next) {
  if (!APP_USER || !APP_PASS) return next();
  const auth = parseBasicAuth(req.headers.authorization);
  if (auth && auth.user === APP_USER && auth.pass === APP_PASS) return next();
  res.setHeader('WWW-Authenticate', 'Basic realm="Maiershirts Tool"');
  return res.status(401).send('Auth required');
}

function toolPasswordMiddleware(req, res, next) {
  if (!TOOL_PASSWORD) return next();
  const supplied = req.body?.password || req.query?.password || req.headers['x-tool-password'];
  if (supplied === TOOL_PASSWORD) return next();
  return fail(res, {
    stage: 'auth',
    status: 'UNAUTHORIZED',
    message: 'Passwort ungültig oder fehlt.',
    technical: buildTechnical({ httpStatus: 401, raw: { message: 'UNAUTHORIZED' } }),
  });
}

function authMiddleware(req, res, next) {
  // wenn Basic Auth aktiv, reicht Basic Auth (TOOL_PASSWORD wird ignoriert)
  if (APP_USER && APP_PASS) return basicAuthMiddleware(req, res, next);
  return toolPasswordMiddleware(req, res, next);
}

// ------------------------------------------------------------
// Rate Limit: TokenBucket 2 req/s + optional MIN_INTERVAL_MS + retry 429
// ------------------------------------------------------------
class TokenBucket {
  constructor({ capacity, refillPerSec }) {
    this.capacity = capacity;
    this.refillPerSec = refillPerSec;
    this.tokens = capacity;
    this.lastRefill = Date.now();
    this.queue = [];
    this.timer = null;
  }
  _refill() {
    const now = Date.now();
    const elapsed = (now - this.lastRefill) / 1000;
    if (elapsed <= 0) return;
    const add = elapsed * this.refillPerSec;
    this.tokens = Math.min(this.capacity, this.tokens + add);
    this.lastRefill = now;
  }
  async acquire() {
    return new Promise((resolve) => {
      this.queue.push(resolve);
      this._drain();
    });
  }
  _drain() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
    this._refill();
    while (this.tokens >= 1 && this.queue.length) {
      this.tokens -= 1;
      const resolve = this.queue.shift();
      resolve();
    }
    if (this.queue.length) {
      this.timer = setTimeout(() => this._drain(), 100);
    }
  }
}

const bucket = new TokenBucket({ capacity: 2, refillPerSec: 2 });
let lastCallTs = 0;

async function enforceMinInterval() {
  if (!MIN_INTERVAL_MS) return;
  const now = Date.now();
  const diff = now - lastCallTs;
  if (diff < MIN_INTERVAL_MS) {
    await new Promise(r => setTimeout(r, MIN_INTERVAL_MS - diff));
  }
  lastCallTs = Date.now();
}

async function lexwareRequest({ method, url, headers, data, responseType, accept }) {
  const maxRetries = 5;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    await bucket.acquire();
    await enforceMinInterval();

    const res = await axios({
      method,
      url,
      headers: {
        Authorization: `Bearer ${API_KEY}`,
        Accept: accept || 'application/json',
        ...(headers || {}),
      },
      data,
      responseType: responseType || 'json',
      validateStatus: () => true,
    });

    if (res.status !== 429) return res;

    // 429 Backoff + jitter
    const base = 800 * Math.pow(2, attempt);
    const jitter = Math.floor(Math.random() * 250);
    const wait = Math.min(12000, base + jitter);
    await new Promise(r => setTimeout(r, wait));
  }

  return { status: 429, data: { message: 'Rate limit exceeded (client retries exhausted)' } };
}

// ------------------------------------------------------------
// Excel helper
// ------------------------------------------------------------
function sheetToJson(wb, name) {
  const sh = wb.Sheets[name];
  return sh ? XLSX.utils.sheet_to_json(sh, { defval: '' }) : null;
}

function sheetRowsToKeyValueObject(rows) {
  if (!rows || !rows.length) return null;

  const first = rows[0];
  const fieldKeys = ['Feld', 'feld', 'Field', 'field'];
  const valueKeys = ['Wert', 'wert', 'Value', 'value', 'val'];

  const fieldCol = fieldKeys.find(k => k in first);
  const valueCol = valueKeys.find(k => k in first);
  if (!fieldCol || !valueCol) return null;

  const obj = {};
  for (const r of rows) {
    const key = String(r[fieldCol] || '').trim();
    if (!key) continue;
    obj[key] = r[valueCol];
  }
  return obj;
}

function numOrNull(v) {
  if (v === '' || v === null || v === undefined) return null;
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}

function toLowerTrim(v) {
  return String(v || '').trim().toLowerCase();
}

function round2(n) {
  return Math.round((Number(n) + Number.EPSILON) * 100) / 100;
}

// ------------------------------------------------------------
// Artikel Cache + Artikel API
// ------------------------------------------------------------
const articleCache = {
  byId: new Map(),
  list: null,
  fetchedAt: 0,
  ttlMs: 10 * 60 * 1000,
};

async function getArticleById(articleId) {
  if (!articleId) return null;
  const cached = articleCache.byId.get(articleId);
  if (cached && (Date.now() - cached._ts) < articleCache.ttlMs) return cached.data;

  const res = await lexwareRequest({
    method: 'GET',
    url: `${API_BASE_URL}/v1/articles/${encodeURIComponent(articleId)}`,
  });

  if (res.status >= 200 && res.status < 300) {
    articleCache.byId.set(articleId, { _ts: Date.now(), data: res.data });
    return res.data;
  }
  return null;
}

async function listAllArticlesCached() {
  if (articleCache.list && (Date.now() - articleCache.fetchedAt) < articleCache.ttlMs) {
    return articleCache.list;
  }

  const all = [];
  let page = 0;
  const size = 250;

  while (true) {
    const res = await lexwareRequest({
      method: 'GET',
      url: `${API_BASE_URL}/v1/articles?page=${page}&size=${size}`,
    });

    if (!(res.status >= 200 && res.status < 300) || !res.data) break;

    const content = Array.isArray(res.data.content) ? res.data.content : [];
    all.push(...content);

    if (res.data.last === true) break;
    if (content.length === 0) break;

    page++;
    if (page > 100) break; // safety
  }

  articleCache.list = all;
  articleCache.fetchedAt = Date.now();
  return all;
}

// ------------------------------------------------------------
// UnitPrice builder (AUTO: Fix für "unit price must not be null")
// ------------------------------------------------------------
function buildUnitPriceFromNetGross({ net, gross, taxRate }) {
  const tr = Number(taxRate ?? 19);
  let netAmount = net != null ? Number(net) : null;
  let grossAmount = gross != null ? Number(gross) : null;

  if (netAmount == null && grossAmount != null) netAmount = grossAmount / (1 + tr / 100);
  if (grossAmount == null && netAmount != null) grossAmount = netAmount * (1 + tr / 100);

  if (netAmount == null || grossAmount == null) return null;

  return {
    currency: 'EUR',
    netAmount: round2(netAmount),
    grossAmount: round2(grossAmount),
    taxRatePercentage: tr,
  };
}

function buildUnitPriceFromExcel({ taxType, amount, taxRate }) {
  const tr = Number(taxRate ?? 19);
  const a = Number(amount);
  if (!Number.isFinite(a)) return null;

  if (String(taxType).trim() === 'gross') {
    return buildUnitPriceFromNetGross({ gross: a, net: null, taxRate: tr });
  }
  return buildUnitPriceFromNetGross({ net: a, gross: null, taxRate: tr });
}

function buildUnitPriceFromArticleObject(article) {
  const p = article?.price;
  if (!p) return null;

  const taxRate = Number(p.taxRate ?? 19);
  const net = p.netPrice != null ? Number(p.netPrice) : null;
  const gross = p.grossPrice != null ? Number(p.grossPrice) : null;

  // falls nur eine Seite vorhanden ist, rechnen wir die andere
  return buildUnitPriceFromNetGross({ net, gross, taxRate });
}

// ------------------------------------------------------------
// Excel -> Quotation Payload (inkl. Regeln + AUTO unitPrice)
// ------------------------------------------------------------
async function parseExcelAndBuildQuotationPayload(excelBase64, { allowPriceOverride }) {
  const errors = [];
  const warnings = [];
  const autoNamedLineItems = [];
  const byType = {};

  // read workbook
  const wb = XLSX.read(Buffer.from(excelBase64, 'base64'), { type: 'buffer' });

  // required sheets
  const angebotRows = sheetToJson(wb, 'Angebot');
  const kundeRows = sheetToJson(wb, 'Kunde');
  const posRows = sheetToJson(wb, 'Positionen');

  if (!angebotRows) errors.push({ sheet: 'Angebot', message: 'Sheet „Angebot“ fehlt.' });
  if (!kundeRows) errors.push({ sheet: 'Kunde', message: 'Sheet „Kunde“ fehlt.' });
  if (!posRows) errors.push({ sheet: 'Positionen', message: 'Sheet „Positionen“ fehlt.' });

  if (errors.length) return { ok: false, payload: null, summary: { errors, warnings } };

  // Angebot: vertikal oder horizontal
  const angebot = sheetRowsToKeyValueObject(angebotRows) || angebotRows[0] || {};
  const taxType = String(angebot.taxType || angebot.TaxType || angebot.TAXTYPE || '').trim();

  if (!taxType) {
    errors.push({ sheet: 'Angebot', row: 2, field: 'taxType', message: 'taxType ist Pflicht (z. B. „gross“ oder „net“).' });
  }

  // Kunde: vertikal oder horizontal
  const kunde = sheetRowsToKeyValueObject(kundeRows) || kundeRows[0] || {};
  const customerName = String(kunde.name || kunde.Name || '').trim();

  if (!customerName) {
    errors.push({ sheet: 'Kunde', row: 2, field: 'name', message: 'Kundenname ist Pflicht.' });
  }

  // taxConditions Pflicht (nicht null)
  const taxConditions = taxType ? { taxType } : null;
  if (!taxConditions) {
    errors.push({ sheet: 'Angebot', row: 2, field: 'taxConditions', message: 'taxConditions.taxType ist Pflicht.' });
  }

  // voucherDate muss ISO datetime sein
  const voucherDate = new Date().toISOString();
  const expirationDate = new Date(Date.now() + 30 * 24 * 3600 * 1000).toISOString();

  // Address (contactId optional)
  const address = {
    name: customerName || undefined,
    contactId: String(kunde.contactId || '').trim() || undefined,
    street: String(kunde.street || '').trim() || undefined,
    zip: String(kunde.zip || '').trim() || undefined,
    city: String(kunde.city || '').trim() || undefined,
    countryCode: String(kunde.countryCode || 'DE').trim() || 'DE',
    contactPerson: String(kunde.contactPerson || '').trim() || undefined,
    email: String(kunde.email || '').trim() || undefined,
    phone: String(kunde.phone || '').trim() || undefined,
  };

  // Positions -> lineItems
  const lineItems = [];

  for (let i = 0; i < posRows.length; i++) {
    const row = posRows[i];
    const excelRow = i + 2;

    const type = toLowerTrim(row.type);
    const articleId = String(row.articleId || row.articleID || '').trim();

    let name = String(row.name || '').trim();
    const description = String(row.description || '').trim();

    const qty = numOrNull(row.quantity ?? row.qty ?? row.Qty ?? row.Menge ?? row.menge);
    const unitName = String(row.unitName || row.unit || '').trim();

    const unitPriceAmount = numOrNull(row.unitPriceAmount ?? row.unitPrice ?? row.price ?? row.Preis);
    const taxRatePercentage = numOrNull(row.taxRatePercentage ?? row.taxRate ?? row.tax);
    const discountPercent = numOrNull(row.discountPercent ?? row.discount);

    // skip fully empty
    const hasAny = type || articleId || name || description || qty || unitName || unitPriceAmount || taxRatePercentage || discountPercent;
    if (!hasAny) continue;

    // type required
    if (!type) {
      errors.push({ sheet: 'Positionen', row: excelRow, field: 'type', message: 'type ist Pflicht.' });
      continue;
    }
    byType[type] = (byType[type] || 0) + 1;

    // text: no qty/unit needed
    if (type === 'text') {
      const txtName = name || description || `Hinweis ${excelRow}`;
      lineItems.push({
        type: 'text',
        name: txtName,
        description: description || undefined,
      });
      continue;
    }

    // qty required
    if (!(qty > 0)) {
      errors.push({ sheet: 'Positionen', row: excelRow, field: 'qty', message: 'qty muss größer als 0 sein.' });
      continue;
    }

    // unitName required
    if (!unitName) {
      errors.push({ sheet: 'Positionen', row: excelRow, field: 'unitName', message: 'unitName ist Pflicht.' });
      continue;
    }

    // material/service: articleId required
    if ((type === 'material' || type === 'service') && !articleId) {
      errors.push({ sheet: 'Positionen', row: excelRow, field: 'articleId', message: 'articleId ist Pflicht bei type=material/service.' });
      continue;
    }

    // name auto from article if empty + articleId set
    let articleObj = null;
    if (articleId) {
      articleObj = await getArticleById(articleId);
      if (!articleObj) {
        // Artikel nicht ladbar -> klarer Fehler (sonst später unitPrice null)
        errors.push({
          sheet: 'Positionen',
          row: excelRow,
          field: 'articleId',
          message: `Artikel konnte nicht geladen werden (articleId=${articleId}). Prüfe ID oder API-Key.`,
        });
        continue;
      }
    }

    if (!name && articleId) {
      const autoName = articleObj?.title || `Artikel ${articleId}`;
      name = autoName;
      autoNamedLineItems.push({ row: excelRow, articleId, name: autoName });
      warnings.push({ sheet: 'Positionen', row: excelRow, message: `Name war leer → automatisch aus Artikel ergänzt: "${autoName}".` });
    }
    if (!name) {
      name = `Position ${excelRow}`;
      autoNamedLineItems.push({ row: excelRow, articleId: articleId || null, name });
      warnings.push({ sheet: 'Positionen', row: excelRow, message: `Name war leer → automatisch gesetzt: "${name}".` });
    }

    const item = {
      type, // material | service | custom
      name,
      description: description || undefined,
      quantity: qty,
      unitName,
    };

    // Lexware verlangt häufig id für material/service
    if (articleId && (type === 'material' || type === 'service')) {
      item.id = articleId;
    }

    // ----------------------------
    // ✅ AUTO unitPrice (FIX)
    // Lexware verlangt: unitPrice must not be null
    //
    // Regel:
    // 1) Wenn Excel Preis da -> nutzen (net/gross)
    // 2) Wenn Excel Preis leer, aber articleId da -> Preis aus Artikelstamm (immer)
    // 3) Wenn Excel Preis leer und keine articleId -> Fehler
    //
    // Hinweis:
    // - Für material/service ignorieren wir Excel Preis weiterhin,
    //   aber wir setzen unitPrice automatisch aus Artikelstamm (statt null).
    // - Für custom:
    //   - wenn articleId vorhanden UND allowPriceOverride=false UND Excel leer -> Artikelpreis
    //   - wenn allowPriceOverride=true -> Excel Preis darf überschreiben (wenn vorhanden),
    //     sonst fallback Artikelpreis
    // ----------------------------
    const taxTypeNorm = String(taxType || '').trim();

    // 1) Excel Preis nutzen?
    const canUseExcelPrice =
      unitPriceAmount !== null &&
      // material/service: Excel Preis wird ignoriert (wie vorher)
      !(type === 'material' || type === 'service') &&
      // custom mit articleId: Excel Preis nur wenn override erlaubt
      !(type === 'custom' && articleId && allowPriceOverride !== true);

    if (canUseExcelPrice) {
      const rate = taxRatePercentage !== null ? taxRatePercentage : 19;
      const up = buildUnitPriceFromExcel({ taxType: taxTypeNorm, amount: unitPriceAmount, taxRate: rate });
      if (!up) {
        errors.push({ sheet: 'Positionen', row: excelRow, field: 'unitPriceAmount', message: 'unitPrice konnte aus Excel nicht gebaut werden.' });
        continue;
      }
      item.unitPrice = up;
    } else {
      // 2) Fallback Artikelpreis?
      if (articleId) {
        const up = buildUnitPriceFromArticleObject(articleObj);
        if (!up) {
          errors.push({
            sheet: 'Positionen',
            row: excelRow,
            field: 'unitPriceAmount',
            message: `Preis fehlt/ist unvollständig im Artikelstamm (articleId=${articleId}).`,
          });
          continue;
        }
        // Wenn taxType net/gross: Lexware akzeptiert meist nur eine Seite,
        // aber wir senden robust net+gross zusammen (keine nulls).
        item.unitPrice = up;

        // Warnung wenn Excel leer oder ignoriert
        if (unitPriceAmount === null || type === 'material' || type === 'service') {
          warnings.push({
            sheet: 'Positionen',
            row: excelRow,
            message: `Preis automatisch aus Artikelstamm gesetzt (articleId=${articleId}).`,
          });
        }
      } else {
        // 3) Kein Artikel und kein brauchbarer Excel Preis -> Fehler
        if (unitPriceAmount === null) {
          errors.push({
            sheet: 'Positionen',
            row: excelRow,
            field: 'unitPriceAmount',
            message: 'Preis ist Pflicht, wenn keine articleId gesetzt ist.',
          });
          continue;
        }
        // falls wir hier landen (z.B. custom ohne articleId, aber canUseExcelPrice false),
        // setzen wir trotzdem aus Excel:
        const rate = taxRatePercentage !== null ? taxRatePercentage : 19;
        const up = buildUnitPriceFromExcel({ taxType: taxTypeNorm, amount: unitPriceAmount, taxRate: rate });
        if (!up) {
          errors.push({ sheet: 'Positionen', row: excelRow, field: 'unitPriceAmount', message: 'unitPrice konnte aus Excel nicht gebaut werden.' });
          continue;
        }
        item.unitPrice = up;
      }
    }

    // Discount
    if (discountPercent !== null) {
      item.discountPercentage = discountPercent;
    }

    // FINAL CHECK: unitPrice must exist (sonst wieder 406)
    if (!item.unitPrice) {
      errors.push({
        sheet: 'Positionen',
        row: excelRow,
        field: 'unitPriceAmount',
        message: 'unitPrice fehlt (würde Lexware 406 auslösen).',
      });
      continue;
    }

    lineItems.push(item);
  }

  if (!lineItems.length) {
    errors.push({ sheet: 'Positionen', message: 'Keine Positionen gefunden.' });
  }

  const summary = {
    errors,
    warnings,
    byType,
    autoNamedLineItems,
    allowPriceOverrideUsed: !!allowPriceOverride,
    voucherDate,
    taxType,
  };

  if (errors.length) return { ok: false, payload: null, summary };

  const payload = {
    voucherDate,
    expirationDate,
    address,
    lineItems,
    totalPrice: { currency: 'EUR' },
    taxConditions,
    shippingConditions: { shippingType: 'none' },
  };

  return { ok: true, payload, summary };
}

// ------------------------------------------------------------
// Idempotency (gegen 3x Erstellung)
// ------------------------------------------------------------
const inFlight = new Map();

function hashRequest({ excelData, allowPriceOverride, finalize }) {
  return crypto
    .createHash('sha256')
    .update(String(finalize ? '1' : '0'))
    .update('|')
    .update(String(allowPriceOverride ? '1' : '0'))
    .update('|')
    .update(excelData)
    .digest('hex');
}

// ------------------------------------------------------------
// API
// ------------------------------------------------------------
app.get('/api/ping', (req, res) => {
  ok(res, {
    status: 'OK',
    passwordProtected: !!(TOOL_PASSWORD || (APP_USER && APP_PASS)),
    passwordMode: (APP_USER && APP_PASS) ? 'basic' : (TOOL_PASSWORD ? 'toolPassword' : 'none'),
    allowPriceOverrideDefault: ALLOW_PRICE_OVERRIDE_DEFAULT,
    minIntervalMs: MIN_INTERVAL_MS,
    apiBaseUrl: API_BASE_URL,
    finalizeDefault: FINALIZE_DEFAULT,
  });
});

app.get('/api/articles', authMiddleware, async (req, res) => {
  try {
    if (!API_KEY) {
      return fail(res, {
        stage: 'config',
        status: 'CONFIG_ERROR',
        message: 'API Key fehlt.',
        technical: buildTechnical({ httpStatus: 500, raw: { message: 'NO_API_KEY' } }),
      });
    }
    const list = await listAllArticlesCached();
    ok(res, { status: 'SUCCESS', data: { count: list.length, articles: list } });
  } catch (err) {
    fail(res, {
      stage: 'articles',
      status: 'ERROR',
      message: err.message,
      technical: buildTechnical({ httpStatus: 500, raw: { message: 'ARTICLES_EXCEPTION' }, err }),
    });
  }
});

app.post('/api/test-excel', authMiddleware, async (req, res) => {
  try {
    const { excelData, allowPriceOverride } = req.body || {};
    const allow = typeof allowPriceOverride === 'boolean' ? allowPriceOverride : ALLOW_PRICE_OVERRIDE_DEFAULT;

    if (!excelData) {
      return fail(res, {
        stage: 'input',
        status: 'VALIDATION_ERROR',
        message: 'Keine Excel-Daten übergeben.',
        technical: buildTechnical({ httpStatus: 400, raw: { message: 'NO_EXCEL' } }),
      });
    }

    const parsed = await parseExcelAndBuildQuotationPayload(excelData, { allowPriceOverride: allow });

    if (!parsed.ok) {
      return fail(res, {
        stage: 'validation',
        status: 'VALIDATION_ERROR',
        message: 'Excel enthält Validierungsfehler. Details siehe errors.',
        data: { summary: parsed.summary },
      });
    }

    ok(res, {
      stage: 'test',
      status: 'SUCCESS',
      message: 'Test erfolgreich — keine kritischen Fehler.',
      data: { summary: parsed.summary },
    });
  } catch (err) {
    fail(res, {
      stage: 'test',
      status: 'ERROR',
      message: err.message,
      technical: buildTechnical({ httpStatus: 500, raw: { message: 'TEST_EXCEPTION' }, err }),
    });
  }
});

app.post('/api/create-offer', authMiddleware, async (req, res) => {
  const startedAt = Date.now();
  try {
    const { excelData, allowPriceOverride, finalize } = req.body || {};
    const allow = typeof allowPriceOverride === 'boolean' ? allowPriceOverride : ALLOW_PRICE_OVERRIDE_DEFAULT;
    const doFinalize = typeof finalize === 'boolean' ? finalize : FINALIZE_DEFAULT;

    if (!excelData) {
      return fail(res, {
        stage: 'input',
        status: 'VALIDATION_ERROR',
        message: 'Keine Excel-Daten übergeben.',
        technical: buildTechnical({ httpStatus: 400, raw: { message: 'NO_EXCEL' } }),
      });
    }
    if (!API_KEY) {
      return fail(res, {
        stage: 'config',
        status: 'CONFIG_ERROR',
        message: 'API Key fehlt.',
        technical: buildTechnical({ httpStatus: 500, raw: { message: 'NO_API_KEY' } }),
      });
    }

    const key = hashRequest({ excelData, allowPriceOverride: allow, finalize: doFinalize });
    if (inFlight.has(key)) {
      const cached = await inFlight.get(key);
      return res.json(cached);
    }

    const promise = (async () => {
      const parsed = await parseExcelAndBuildQuotationPayload(excelData, { allowPriceOverride: allow });

      if (!parsed.ok) {
        return {
          ok: false,
          stage: 'validation',
          status: 'VALIDATION_ERROR',
          message: 'Excel enthält Validierungsfehler. Details siehe errors.',
          data: { summary: parsed.summary },
        };
      }

      const url = `${API_BASE_URL}/v1/quotations${doFinalize ? '?finalize=true' : ''}`;
      const apiRes = await lexwareRequest({
        method: 'POST',
        url,
        headers: { 'Content-Type': 'application/json' },
        data: parsed.payload,
        accept: 'application/json',
      });

      if (apiRes.status < 200 || apiRes.status >= 300) {
        return {
          ok: false,
          stage: 'lexware-create',
          status: apiRes.status === 429 ? 'RATE_LIMIT' : 'ERROR',
          message: apiRes.status === 429 ? 'Rate limit exceeded' : 'Lexware API Fehler',
          technical: buildTechnical({ httpStatus: apiRes.status, raw: apiRes.data }),
          data: { summary: parsed.summary },
        };
      }

      return {
        ok: true,
        stage: 'lexware-create',
        status: 'SUCCESS',
        message: 'Angebot erstellt.',
        data: {
          quotationId: apiRes.data?.id || null,
          summary: parsed.summary,
          ms: Date.now() - startedAt,
        },
      };
    })();

    inFlight.set(key, promise);
    const result = await promise;
    setTimeout(() => inFlight.delete(key), 15000);

    return res.json(result);
  } catch (err) {
    return fail(res, {
      stage: 'lexware-create',
      status: 'ERROR',
      message: err.message || 'Unerwarteter Fehler',
      technical: buildTechnical({ httpStatus: 500, raw: { message: 'UNHANDLED_EXCEPTION' }, err }),
    });
  }
});

app.get('/api/download-pdf', authMiddleware, async (req, res) => {
  try {
    const quotationId = String(req.query.id || '').trim();
    if (!quotationId) return res.status(400).send('Missing id');
    if (!API_KEY) return res.status(500).send('API Key fehlt');

    const apiRes = await lexwareRequest({
      method: 'GET',
      url: `${API_BASE_URL}/v1/quotations/${encodeURIComponent(quotationId)}/file`,
      responseType: 'arraybuffer',
      accept: '*/*',
    });

    if (apiRes.status < 200 || apiRes.status >= 300) {
      return res.status(200).json({
        ok: false,
        stage: 'lexware-pdf',
        status: apiRes.status === 429 ? 'RATE_LIMIT' : 'ERROR',
        message: apiRes.status === 429 ? 'Rate limit exceeded' : 'Lexware PDF Fehler',
        technical: buildTechnical({ httpStatus: apiRes.status, raw: apiRes.data }),
      });
    }

    const contentType = apiRes.headers['content-type'] || 'application/pdf';
    const disposition = apiRes.headers['content-disposition'] || 'attachment; filename="quotation.pdf"';

    res.setHeader('Content-Type', contentType);
    res.setHeader('Content-Disposition', disposition);
    return res.status(200).send(Buffer.from(apiRes.data));
  } catch (err) {
    return res.status(200).json({
      ok: false,
      stage: 'lexware-pdf',
      status: 'ERROR',
      message: err.message,
      technical: buildTechnical({ httpStatus: 500, raw: { message: 'PDF_EXCEPTION' }, err }),
    });
  }
});

// ------------------------------------------------------------
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log('Server läuft auf Port', PORT));
